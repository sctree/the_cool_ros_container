/* esm.sh - github:jeff-hykin/good-js#40797ac/source/flattened/parse_args */
var R=n=>n.replace(/([a-z0-9])([A-Z])/g,"$1_$2").replace(/[^a-zA-Z0-9 _.-]/,"_").toLowerCase().split(/[ _.-]+/g).filter(o=>o);var Z=n=>{let a=R(n).map(o=>o.replace(/^\w/,l=>l.toUpperCase()));return a.length>0&&(a[0]=a[0].toLowerCase()),a.join("")};function C(n,r){n.length>r.length&&([n,r]=[r,n]);let a=Array.from({length:n.length+1},(o,l)=>+l);for(let o=0;o<r.length;o++){let l=[o+1];for(let d=0;d<n.length;d++){let y=n[d],f=r[o];y===f?l.push(a[d]):l.push(1+Math.min(a[d],a[d+1],l[l.length-1]))}a=l}return a[a.length-1]}var x=class extends Error{constructor(r,{givenWord:a,givenWords:o,possibleWords:l}){super(r),this.givenWord=a,this.givenWords=o,this.possibleWords=l}};function I(n){var{givenWord:r,givenWords:a,possibleWords:o,caseSensitive:l,autoThrow:d,suggestionLimit:y}={suggestionLimit:1/0,...n};if(a instanceof Array){let f={};for(let v of a)f[v]=I({...n,givenWord:v,givenWords:void 0});return f}if(l||(o=o.map(f=>f.toLowerCase()),r=r.toLowerCase()),!o.includes(r)&&d){let f=I({givenWord:r,possibleWords:o,caseSensitive:l,suggestionLimit:y});throw y==1&&f.length>0?new x(`For ${JSON.stringify(r)}, did you mean ${JSON.stringify(f[0])}?`,{givenWord:r,possibleWords:f}):new x(`For ${JSON.stringify(r)}, did you mean one of ${JSON.stringify(f)}?`,{givenWords:a,possibleWords:f})}return[...o].sort((f,v)=>C(r,f)-C(r,v)).slice(0,y)}var Q=Symbol("flagArg"),X=Symbol("requiredArg"),m=Symbol("unset"),k=class{constructor(r){this.val=r}},$=class extends Error{constructor(r,a){super(r),Object.assign(this,a)}},ae=n=>new k(n),Y=(n,r)=>{if(n instanceof Array)try{return r(n)}catch{let o=[];for(let l of n)try{o.push(r(l))}catch{o.push(l)}return o}else if(n!==void 0&&n!==m)try{return r(n)}catch{}return n};function le({rawArgs:n,fields:r,namedArgsStopper:a="--",allowNameRepeats:o=!0,nameTransformer:l=Z,valueTransformer:d=JSON.parse,isolateArgsAfterStopper:y=!1,argsByNameSatisfiesNumberedArg:f=!0,allowImplicitNamedArgs:v=!0,allowImplicitNumberedArgs:K=!0,implicitNamePattern:F=/^(--|-)[a-zA-Z0-9\-_]+$/,implictFlagPattern:T=null}){let D=[],_=[],u=new Map;for(let[e,...t]of r){let s=t.includes(Q),i=t.includes(X),c=t.some(g=>g instanceof k),b=t.some(g=>g instanceof Function),W={isRequired:i,isFlag:s,isExplicit:!0,hasTransformer:b,wasNamed:!1,keys:e,kind:t,realIndices:[],value:m,hasDefaultValue:c,default:c?t.filter(g=>g instanceof k)[0].val:void 0};for(let g of e){if(u.has(g))throw Error(`When calling parseArgs(), there's at least two arguments that are both trying to use this name ${JSON.stringify(g)}. A name can only belong to one argument.`);u.set(g,W),typeof g=="string"&&D.push(g)}if(s)for(let g of e)typeof g=="string"&&_.push(g)}let q=[],U=[],G=[],S=[],O={},M=!1,A=null,p=-1,h=-1,j=null,J=[],H=(e,t)=>{S.push(t);e:for(;;){if(p+=1,u.has(p)){let s=u.get(p);if(s.value!=m){if(f)continue e;if(o)s.value=[s.value,t];else{let i=s.keys.filter(b=>typeof b=="string"),c=i.reduce((b,W)=>b.length>W.length?b:W);throw new $(`When calling parseArgs(), two values were given for the same entry (ex: "count $thisVal 5 --min $thisVal" instead of "count --min $thisVal --max 5" or "count $thisVal 5"). The second occurance was ${JSON.stringify(t)}, and the field was ${JSON.stringify(i)}`,{reason:"argNotAllowed",badArg:t,badArgRealIndex:e,badArgName:c,badArgNames:i})}}else O[p]=t,s.value=t;s.realIndices.push(e)}else{if(!K){let s=Math.max(0,...u.keys().filter(c=>Number.isInteger(c)&&c>=0)),i="";throw e>0&&(i=`
The previous argument was ${JSON.stringify(n[e-1])}`),s==0?new $(`Sorry, numbered arguments are not allowed.
The bad argument was ${JSON.stringify(t)}${i}`,{reason:"argNotAllowed",badArg:t,badArgRealIndex:e}):new $(`Sorry, only ${s} numbered arguments are allowed.
The bad argument was ${JSON.stringify(t)}${i}`,{reason:"argNotAllowed",badArg:t,badArgRealIndex:e})}U.push(p),u.set(p,{kind:[],keys:[p],realIndices:[e],value:t})}break}};for(let e of n){if(h+=1,A!=null){let s=A;if(A=null,!u.has(s))v||I({givenWord:s,possibleWords:[...u.keys()].filter(i=>typeof i=="string"),autoThrow:!0,suggestionLimit:3}),G.push(s),u.set(s,{wasNamed:!0,kind:[],keys:[s],realIndices:[h],value:e});else{let i=u.get(s);if(i.wasNamed=!0,i.value!==m)if(o)i.value=[i.value,e];else throw Error(`When calling parseArgs(), two values (ex: "--min 5 --minimum 5" or "--m 5 --m 5") were given to the same field. The second occurance was ${s}, and the field was ${JSON.stringify(i.keys)} `);else i.value=e;i.realIndices.push(h-1),i.realIndices.push(h)}continue}if(e==a){M=!0,j=h;continue}if(M){q.push(e),y||J.push([h,e]);continue}let t;if(_.includes(e)){let s=u.get(e);if(s.value!=m){if(!o)throw Error(`When calling parseArgs(), two values (ex: "--min 5 --minimum 5" or "--m 5 --m 5") were given to the same field. The second occurance was ${e}, and the field was ${JSON.stringify(s.keys)} `)}else s.value=!0;s.realIndices.push(h)}else D.includes(e)||F&&(t=e.match(F))?A=e:T&&(t=e.match(T))?u.has(e)?u.get(e).realIndices.push(h):u.set(p,{isFlag:!0,kind:[],keys:[e],realIndices:[h],value:!0}):J.push([h,e])}for(let[e,t]of J)H(e,t);let w={},L={},N=new Set(u.values());for(let e of N){let t=e.keys.filter(s=>typeof s=="string");if(t.length>0)if(!l)w[t[0]]=null;else{let s=t.map(l).flat(1);w[s[0]]=null;let i=s.filter(c=>!t.includes(c));e.keys=e.keys.concat(i);for(let c of i)u.set(c,e)}}for(let e of N){if(e.isRequired&&e.value==m)throw Error(`

The ${e.keys.map(s=>typeof s=="number"?`[Arg #${s}]`:s).join(" ")} field is required but it was not provided
`);if(e.hasDefaultValue&&e.value==m)e.value=e.default;else if(e.hasTransformer)for(let s of e.kind)s instanceof Function&&(e.value=s(e.value));else d&&!e.isFlag&&(e.value=Y(e.value,d));e.isFlag&&(e.value==m?e.value=!1:e.value=!!e.value);for(let s of e.keys)typeof s=="number"?O[s]=e.value:typeof s=="string"&&(L[s]=e.value)}let V={},B=[];for(let{isExplicit:e,value:t,keys:s}of N)e||(typeof s[0]=="number"?B.push(t):(V[s[0]]=t,V[l(s[0])]=t));let z={},E=[];for(let{isExplicit:e,kind:t,value:s,keys:i}of N)if(e)for(let c of i)typeof c=="number"?E[c]=s:z[c]=s;for(let e of Object.keys(w))w[e]=L[e],w[e]===m&&(w[e]=void 0);return d&&(S=S.map(e=>Y(e,d))),{simplifiedNames:w,argList:E.concat(B),explicitArgsByNumber:E,implicitArgsByNumber:B,directArgList:S,argsAfterStopper:q,arg:e=>typeof e=="number"?O[e]:L[e],fields:[...N],field:e=>u.get(e),explicitArgsByName:z,implicitArgsByName:V,nameStopIndex:j}}export{$ as ArgumentError,x as DidYouMeanError,Q as flag,ae as initialValue,le as parseArgs,X as required};
//# sourceMappingURL=parse_args.mjs.map
// denoCacheMetadata={"headers":{"content-type":"application/javascript; charset=utf-8","date":"Mon, 21 Jul 2025 21:50:30 GMT","server":"cloudflare","alt-svc":"h3=\":443\"; ma=86400","vary":"Accept-Encoding","cache-control":"public, max-age=31536000, immutable","access-control-allow-origin":"*","last-modified":"Mon, 21 Jul 2025 21:50:30 GMT","cf-cache-status":"MISS","cf-ray":"962dea0dbe7ef0be-DFW"},"url":"https://esm.sh/gh/jeff-hykin/good-js@40797ac/denonext/source/flattened/parse_args.mjs","time":1753134630}